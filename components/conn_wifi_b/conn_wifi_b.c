/**
 * This file is part of esp32-fuota.
 *
 * esp32-fuota is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * esp32-fuota is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with esp32-fuota. If not, see <https://www.gnu.org/licenses/>.
 *
 * Copyright 2023 Pascal Bodin
 */

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "freertos/task.h"
#include "freertos/timers.h"

#include "esp_event.h"
#include "esp_log.h"
#include "esp_wifi.h"

#include "conn_wifi_b.h"

// Task stack size.
#define CWB_STACK_DEPTH_MIN 2800

// Wait time for xQueueReceive(), in ms.
static const uint32_t WAIT_QUEUE_REC_MS = 60000;

// Wait time for timer functions, in ms.
static const uint32_t WAIT_TIMER_MS = 500;

// Semaphore timeout. It is used as a last-chance mechanism in case something
// goes wrong in the component: it gives control back to the client application.
// Its value must be greater than the IP address assignment timeout.
static const uint32_t SEMAPHORE_TIMEOUT_MS = 20000;

static const UBaseType_t TASK_PRIO = 5;
static const UBaseType_t QUEUE_LENGTH = 3;

static const size_t SSID_MAX_LENGTH = 32;
static const size_t PASSWORD_MAX_LENGTH = 64;

const char CWB_TAG[] = "CWB";

// FSA states. In case of system error, ST_ERROR state is entered.
// Starting from this instant, every client application service
// request is responded with CWB_ERROR. It is then up to the application
// to restart the ESP32.
typedef enum {
    ST_WAIT_STARTUP,
    ST_WAIT_STA,
    ST_WAIT_IP,
    ST_WAIT_DIS_CMD,
    ST_WAIT_DIS,
    ST_WAIT_STOP,
    ST_WAIT_DIS_ON_PB,
    ST_WAIT_STOP_ON_PB,
    ST_ERROR,           // Entered in case of system error.
} state_t;

static state_t current_state = ST_WAIT_STARTUP;

// Structure of messages exchanged between service functions and
// component task, and internally.
typedef enum {
    // Service function messages.
    MSG_CONNECT,        // Connection request.
    MSG_DISCONNECT,     // Disconnection request.
    // Internal messages.
    MSG_STA_OK,         // ESP-IDF station started.
    MSG_IP,             // IP address assigned.
    MSG_TIMEOUT,        // Timeout of IP address assignment.
    MSG_DIS,            // Disconnected from the AP.
    MSG_STOP,           // ESP-IDF station stopped.
} msg_type_t;

typedef struct {
    uint8_t *ssid;
    uint8_t *password;
    uint32_t ip_timeout;
} connect_t;

typedef struct {
    msg_type_t type;
    union {
        connect_t connect;
    };
} msg_t;

static TaskHandle_t task_handle = NULL;

// Task message queue.
static QueueHandle_t queue = NULL;

// Semaphore used to block.
static SemaphoreHandle_t semaphore = NULL;

// Variable used to transfer the operation result from the task to
// the blocking service function. This variable is modified only by
// actions resulting directly from a client request. For instance,
// it is set after a call to cw_connect_b(). But it is not set after
// a loss of connectivity detected by the task. This ensures that
// the variable transfers the correct operation result to the client.
// Remembering the loss of connectivity is done by the FSA state.
static volatile cwb_status_t operation_result;

// Is Wi-Fi initialized?
static volatile bool wifi_initialized = false;

// ESP-NETIF instance.
static esp_netif_t *netif_instance;

// Event handler instances, used to unregister event handler.
static esp_event_handler_instance_t wifi_event_handler_instance;
static esp_event_handler_instance_t ip_event_handler_instance;

/**
 * Event handler for events generated by the Wi-Fi task and the LwIP task.
 */
static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data) {

    msg_t msg;
    BaseType_t frt_rs;

    bool msg_to_send = true;

    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        // Station initialization done. LwIP network interface initialized.
        ESP_LOGI(CWB_TAG, "WIFI_EVENT_STA_START");
        msg.type = MSG_STA_OK;
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        ESP_LOGI(CWB_TAG, "WIFI_EVENT_STA_DISCONNECTED");
        // We were not able to connect, or we were connected and got disconnected,
        // or we requested a disconnection while connected. LwIP network
        // interface is shut down.
        msg.type = MSG_DIS;
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_STOP) {
        ESP_LOGI(CWB_TAG, "WIFI_EVENT_STA_STOP");
        // IP address is released, DHCP client is stopped LwIP network
        // interface is cleared.
        msg.type = MSG_STOP;
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ESP_LOGI(CWB_TAG, "IP_EVENT_STA_GOT_IP");
        // We got an IP address.
        msg.type = MSG_IP;
    } else {
        ESP_LOGI(CWB_TAG, "Event: %d", event_id);
        msg_to_send = false;
    }

    if (msg_to_send) {
        // We are sure that the queue is not NULL as Wi-Fi is started after
        // task creation.
        frt_rs = xQueueSend(queue, &msg, 0);
        if (frt_rs != pdTRUE) {
            ESP_LOGE(CWB_TAG, "event_handler - Error from xQueueSend");
        }
    }

}

/**
 * Timer handler.
 */
static void timer_handler(TimerHandle_t timer) {

    msg_t msg;
    msg.type = MSG_TIMEOUT;
    BaseType_t frt_rs = xQueueSend(queue, &msg, 0);
    if (frt_rs != pdTRUE) {
        ESP_LOGE(CWB_TAG, "timer_handler - Error from xQueueSend");
    }

}

/**
 * Returns true if Wi-Fi initialization is OK, false otherwise.
 */
static bool init_wifi(void) {

    esp_err_t esp_rs;

    netif_instance = esp_netif_create_default_wifi_sta();
    if (netif_instance == NULL) {
        ESP_LOGE(CWB_TAG, "Error from esp_netif_create_default_wifi_sta");
        return false;
    }
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_rs = esp_wifi_init(&cfg);
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from esp_wifi_init: %d", esp_rs);
        return false;
    }
    // Register our event_handle that will receive Wi-Fi task events.
    esp_rs = esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler,
            NULL, &wifi_event_handler_instance);
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from Wi-Fi esp_event_handler_instance_register: %s", esp_err_to_name(esp_rs));
        esp_wifi_deinit();
        return false;
    }
    // And register the same event handler to receive the event telling that an
    // IP address has been assigned. esp_netif will automatically start the DHCP client
    // once the Wi-Fi task is connected to the AP.
    esp_rs = esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler,
            NULL, &ip_event_handler_instance);
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from IP esp_event_handler_instance_register: %s", esp_err_to_name(esp_rs));
        esp_wifi_deinit();
        return false;
    }
    esp_rs = esp_wifi_set_mode(WIFI_MODE_STA);
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from esp_wifi_set_mode: %s", esp_err_to_name(esp_rs));
        esp_wifi_deinit();
        return false;
    }
    // At this stage, Wi-Fi initialization is OK.
    wifi_initialized = true;
    return true;

}

cwb_status_t cwb_deinit_b(void) {

    esp_err_t esp_rs;

    // Unregister event handler.
    esp_rs = esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID,
                                                   wifi_event_handler_instance);
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from Wi-Fi esp_event_handler_unregister: %s", esp_err_to_name(esp_rs));
        return CWB_SYS_ERR;
    }
    esp_rs = esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP,
                                                   ip_event_handler_instance);
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from IP esp_event_handler_unregister: %s", esp_err_to_name(esp_rs));
        return CWB_SYS_ERR;
    }
    esp_rs = esp_wifi_deinit();
    if (esp_rs != ESP_OK) {
        ESP_LOGE(CWB_TAG, "Error from esp_wifi_deinit: %s", esp_err_to_name(esp_rs));
        return CWB_SYS_ERR;
    }
    esp_netif_destroy(netif_instance);
    wifi_initialized = false;
    return CWB_OK;

}

/**
 * Component task, created at first service request from the client application.
 */
static void cwb_task(void *pvParameters) {

    esp_err_t esp_rs;   // Return status for ESP-IDF calls.
    BaseType_t frt_rs;  // Return status for FreeRTOS calls.
    bool boo_rs;
    cwb_status_t cwb_rs;

    msg_t msg;

    // Wait period used for xTicksToWait when calling xQueueReceive().
    const TickType_t wait_queue_rec = pdMS_TO_TICKS(WAIT_QUEUE_REC_MS);

    // Wait period used for xBlockTime when calling timer functions.
    const TickType_t wait_timer = pdMS_TO_TICKS(WAIT_TIMER_MS);

    TimerHandle_t ip_timer = NULL;

    // We don't use the timer id, but it is required.
    uint8_t ip_timer_id = 0;

    TickType_t ip_timeout_period = 1;

    // Used to remember that we got an IP timeout.
    bool ip_timeout = false;

    while (true) {

        // Wait for an incoming message. We are sure that queue is not NULL,
        // as the task is started only after the initialization of queue.
        frt_rs = xQueueReceive(queue, &msg, wait_queue_rec);
        if (frt_rs != pdTRUE) {
            // Timeout. Go back to receive.
            ESP_LOGI(CWB_TAG, "Alive");
            continue;
        }

        switch (current_state) {

        case ST_WAIT_STARTUP:
            if (msg.type == MSG_DISCONNECT) {
                ESP_LOGW(CWB_TAG, "WAIT_STARTUP - Not connected");
                operation_result = CWB_ALREADY_DIS;
                // Unblock the client request.
                xSemaphoreGive(semaphore);
                break;
            }
            if (msg.type == MSG_CONNECT) {
                // Important: the log message relies on the fact that SSID is a
                // null-terminated ASCII string.
                ESP_LOGI(CWB_TAG, "WAIT_STARTUP - Starting connection to %s", msg.connect.ssid);
                boo_rs = init_wifi();
                if (!boo_rs) {
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                wifi_config_t wifi_config = {0};
                // Beware: the copy operations below rely on the fact that SSID and password
                // are null-terminated ASCII strings. This is a requirement from current version
                // of ESP-IDF. But this does not conform to Wi-Fi standard.
                // We are sure that pointer to SSID is not null (verified by the service request
                // function).
                strncpy((char *)wifi_config.sta.ssid, (const char *)msg.connect.ssid,
                        SSID_MAX_LENGTH);
                if (msg.connect.password != NULL) {
                    strncpy((char *)wifi_config.sta.password, (const char *)msg.connect.password,
                            PASSWORD_MAX_LENGTH);
                }
                ip_timeout_period = pdMS_TO_TICKS(msg.connect.ip_timeout);
                if (ip_timeout_period == 0) {
                    // Must not be 0.
                    ip_timeout_period = 1;
                }
                wifi_config.sta.bssid_set = false;  // Default value, but better to make it explicit.
                wifi_config.sta.scan_method = WIFI_FAST_SCAN;
                wifi_config.sta.sort_method = WIFI_CONNECT_AP_BY_SIGNAL;
                esp_rs = esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config);
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_STARTUP - Error from esp_wifi_set_config: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                esp_rs = esp_wifi_start();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_STARTUP - Error from esp_wifi_start: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                current_state = ST_WAIT_STA;
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_STARTUP - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_STA:
            if (msg.type == MSG_STA_OK) {
                ESP_LOGI(CWB_TAG, "WAIT_STA - STA OK");
                esp_rs = esp_wifi_connect();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_STA - Error from esp_wifi_connect: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                // It has been observed that we could have an almost infinite wait for
                // an IP address. So we start a timer, to limit the wait period.
                ip_timer = xTimerCreate("CWB_TMR_IP",
                                        ip_timeout_period,
                                        pdFALSE,  // uxAutoReload.
                                        &ip_timer_id,
                                        timer_handler);
                if (ip_timer == NULL) {
                    ESP_LOGE(CWB_TAG, "WAIT_STA - Error from IP xTimerCreate");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                frt_rs = xTimerStart(ip_timer, wait_timer);
                if (frt_rs != pdPASS) {
                    ESP_LOGE(CWB_TAG, "WAIT_STA - Error from xTimerStart");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                current_state = ST_WAIT_IP;
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_STA - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_IP:
            if (msg.type == MSG_DIS) {
                // Disconnected from the AP.
                ESP_LOGI(CWB_TAG, "WAIT_IP - Disconnected");
                // Stop timer.
                frt_rs = xTimerStop(ip_timer, wait_timer);
                if (frt_rs != pdPASS) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from xTimerStop");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                frt_rs = xTimerDelete(ip_timer, wait_timer);
                if (frt_rs != pdPASS) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from xTimerDelete");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                esp_rs = esp_wifi_stop();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from esp_wifi_stop: %s", esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                current_state = ST_WAIT_STOP_ON_PB;
                break;
            }
            if (msg.type == MSG_TIMEOUT) {
                // Stop waiting for IP address assignment.
                ESP_LOGI(CWB_TAG, "WAIT_IP - Stopped waiting for an IP address");
                esp_rs = esp_wifi_disconnect();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from esp_wifi_disconnect: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                frt_rs = xTimerDelete(ip_timer, wait_timer);
                if (frt_rs != pdPASS) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from xTimerDelete");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                // Remember that we got a timeout, in order to be able to return the
                // right status to the client application.
                ip_timeout = true;
                current_state = ST_WAIT_DIS_ON_PB;
                break;
            }
            if (msg.type == MSG_IP) {
                // We got an IP address.
                ESP_LOGI(CWB_TAG, "WAIT_IP - IP address assigned");
                // Stop timer.
                frt_rs = xTimerStop(ip_timer, wait_timer);
                if (frt_rs != pdPASS) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from xTimerStop");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                frt_rs = xTimerDelete(ip_timer, wait_timer);
                if (frt_rs != pdPASS) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from xTimerDelete");
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                // Inform our client.
                operation_result = CWB_OK;
                current_state = ST_WAIT_DIS_CMD;
                frt_rs = xSemaphoreGive(semaphore);
                if (frt_rs != pdTRUE) {
                    ESP_LOGE(CWB_TAG, "WAIT_IP - Error from xSemaphoreGive");
                    // operation_status has already been set.
                    current_state = ST_ERROR;
                    break;
                }
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_IP - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_DIS_CMD:
            if (msg.type == MSG_CONNECT) {
                ESP_LOGW(CWB_TAG, "WAIT_DIS_CMD - Connect request");
                operation_result = CWB_ALREADY_CON;
                // Stay in same state.
                // Unblock the client request.
                frt_rs = xSemaphoreGive(semaphore);
                if (frt_rs != pdTRUE) {
                    ESP_LOGE(CWB_TAG, "WAIT_DIS_CMD - Error from xSemaphoreGive");
                    // operation_status has already been set.
                    current_state = ST_ERROR;
                    break;
                }
                break;
            }
            if (msg.type == MSG_DIS) {
                // When this event occurs, the client has already been unblocked, as
                // we were connected. This means that the semaphore give performed
                // in ST_WAIT_STOP_ON_PB state is not required, for this specific
                // case. But it does not harm.
                ESP_LOGI(CWB_TAG, "WAIT_DIS_CMD - Disconnected");
                esp_rs = esp_wifi_stop();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_DIS_CMD - Error from esp_wifi_stop: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                current_state = ST_WAIT_STOP_ON_PB;
                break;
            }
            if (msg.type == MSG_DISCONNECT) {
                ESP_LOGI(CWB_TAG, "WAIT_DIS_CMD - Disconnection request");
                esp_rs = esp_wifi_disconnect();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_DIS_CMD - Error from esp_wifi_disconnect: %s",
                            esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                current_state = ST_WAIT_DIS;
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_DIS_CMD - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_DIS:
            if (msg.type == MSG_DIS) {
                // Disconnected.
                ESP_LOGI(CWB_TAG, "WAIT_DIS - disconnected");
                esp_rs = esp_wifi_stop();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_DIS - Error from esp_wifi_stop: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                // Let's wait for Wi-Fi to stop.
                current_state = ST_WAIT_STOP;
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_DIS - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_STOP:
            if (msg.type == MSG_STOP) {
                ESP_LOGI(CWB_TAG, "WAIT_STOP - Wif-Fi stopped");
                operation_result = CWB_OK;
                cwb_rs = cwb_deinit_b();
                if (cwb_rs != CWB_OK) {
                	// operation_result already returned.
                	current_state = ST_ERROR;
                	// Unblock the client request.
                	// We don't test return status, as we already are in error state.
                	xSemaphoreGive(semaphore);
                	break;
                }
                // Wait for next connection request.
                current_state = ST_WAIT_STARTUP;
                // Unblock the client request.
                frt_rs = xSemaphoreGive(semaphore);
                if (frt_rs != pdTRUE) {
                    ESP_LOGE(CWB_TAG, "WAIT_STOP - Error from xSemaphoreGive");
                    // operation_status has already been set.
                    current_state = ST_ERROR;
                    break;
                }
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_STOP - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_DIS_ON_PB:
            if (msg.type == MSG_DIS) {
                // Disconnected.
                ESP_LOGI(CWB_TAG, "WAIT_DIS_ON_PB - Disconnected");
                esp_rs = esp_wifi_stop();
                if (esp_rs != ESP_OK) {
                    ESP_LOGE(CWB_TAG, "WAIT_DIS_ON_PB - Error from esp_wifi_stop: %s",
                             esp_err_to_name(esp_rs));
                    operation_result = CWB_SYS_ERR;
                    current_state = ST_ERROR;
                    // Unblock the client request.
                    // We don't test return status, as we already are in error state.
                    xSemaphoreGive(semaphore);
                    break;
                }
                // Let's wait for Wi-Fi to stop.
                current_state = ST_WAIT_STOP_ON_PB;
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_DIS_ON_PB - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_WAIT_STOP_ON_PB:
            if (msg.type == MSG_STOP) {
                ESP_LOGI(CWB_TAG, "WAIT_STOP_ON_PB - Wif-Fi stopped");
                if (ip_timeout) {
                	operation_result = CWB_IP_TIMEOUT;
                	ip_timeout = false;
                } else {
                	operation_result = CWB_DIS;
                }
                cwb_rs = cwb_deinit_b();
                if (cwb_rs != CWB_OK) {
                	// operation_result already returned.
                	current_state = ST_ERROR;
                	// Unblock the client request.
                	// We don't test return status, as we already are in error state.
                	xSemaphoreGive(semaphore);
                	break;
                }
                // Wait for next connection request.
                current_state = ST_WAIT_STARTUP;
                // Unblock the client request.
                frt_rs = xSemaphoreGive(semaphore);
                if (frt_rs != pdTRUE) {
                    ESP_LOGE(CWB_TAG, "WAIT_STOP_ON_PB - Error from xSemaphoreGive");
                    // operation_status has already been set.
                    current_state = ST_ERROR;
                    break;
                }
                break;
            }
            // At this stage, unexpected message.
            ESP_LOGE(CWB_TAG, "WAIT_STOP_ON_PB - Unexpected message: %d", msg.type);
            operation_result = CWB_SYS_ERR;
            current_state = ST_ERROR;
            // Unblock the client request.
            // We don't test return status, as we already are in error state.
            xSemaphoreGive(semaphore);
            break;

        case ST_ERROR:
            // We return a system error to any client request.
            if ((msg.type == MSG_CONNECT) || (msg.type == MSG_DISCONNECT)) {
                operation_result = CWB_SYS_ERR;
            }
            break;

        default:
            ESP_LOGE(CWB_TAG, "Unexpected state: %d", current_state);
            current_state = ST_ERROR;
        }

    }

}

cwb_status_t cwb_connect_b(const uint8_t *ssid, const uint8_t *password,
                           uint32_t ip_timeout_ms) {

    BaseType_t frt_rs;  // Return status for FreeRTOS calls.

    // Has the task already been started by a previous request?
    if (task_handle == NULL) {
        ESP_LOGI(CWB_TAG, "Creating queue and starting task");
        // We must start component's queue, task and semaphore.
        queue = xQueueCreate(QUEUE_LENGTH, sizeof(msg_t));
        if (queue == NULL) {
            ESP_LOGE(CWB_TAG, "Error from xQueueCreate");
            return CWB_SYS_ERR;
        }
        frt_rs = xTaskCreate((TaskFunction_t)cwb_task, "conn_wifi_b",
                             CWB_STACK_DEPTH_MIN, NULL, TASK_PRIO,
                             &task_handle);
        if (frt_rs != pdPASS) {
            ESP_LOGE(CWB_TAG, "Error from xTaskCreate");
            return CWB_SYS_ERR;
        }
        semaphore = xSemaphoreCreateBinary();
        if (semaphore == NULL) {
            ESP_LOGE(CWB_TAG, "Error from xSemaphoreCreateBinary");
            return CWB_SYS_ERR;
        }
    }
    if (ssid == NULL) {
        return CWB_PARAM_ERR;
    }
    // Send request to task.
    ESP_LOGI(CWB_TAG, "Sending connection request to task");
    msg_t msg;
    msg.type = MSG_CONNECT;
    msg.connect.ssid = (uint8_t *)ssid;
    msg.connect.password = (uint8_t *)password;
    msg.connect.ip_timeout = ip_timeout_ms;
    frt_rs = xQueueSend(queue, &msg, 0);
    if (frt_rs != pdTRUE) {
        ESP_LOGE(CWB_TAG, "Error from xQueueSend");
        return CWB_SYS_ERR;
    }
    // Now, wait for response, with timeout.
    TickType_t semaphore_timeout = pdMS_TO_TICKS(SEMAPHORE_TIMEOUT_MS);
    frt_rs = xSemaphoreTake(semaphore, semaphore_timeout);
    if (frt_rs == pdTRUE) {
        // We got an IPv4 address, or are in error state.
        return operation_result;
    }
    // At this stage, we got a timeout.
    return CWB_IP_TIMEOUT;

}

cwb_status_t cwb_disconnect_b(void) {

    BaseType_t frt_rs;  // Return status for FreeRTOS calls.

    if (task_handle == NULL) {
        return CWB_ALREADY_DIS;
    }
    // Send request to task.
    ESP_LOGI(CWB_TAG, "Sendind disconnection request to task");
    msg_t msg;
    msg.type = MSG_DISCONNECT;
    frt_rs = xQueueSend(queue, &msg, 0);
    if (frt_rs != pdTRUE) {
        ESP_LOGE(CWB_TAG, "Error from xQueueSend");
        return CWB_SYS_ERR;
    }
    // Now, wait for response, with timeout.
    TickType_t semaphore_timeout = pdMS_TO_TICKS(SEMAPHORE_TIMEOUT_MS);
    frt_rs = xSemaphoreTake(semaphore, semaphore_timeout);
    if (frt_rs == pdTRUE) {
        // We are disconnected, or in error state.
        return operation_result;
    }
    // At this stage, we got a timeout.
    return CWB_DIS_TIMEOUT;

}
